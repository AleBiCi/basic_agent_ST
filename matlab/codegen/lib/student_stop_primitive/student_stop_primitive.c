/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * student_stop_primitive.c
 *
 * Code generation for function 'student_stop_primitive'
 *
 */

/* Include files */
#include "student_stop_primitive.h"
#include "rt_nonfinite.h"
#include "rt_nonfinite.h"
#include <math.h>

/* Function Declarations */
static double rt_powd_snf(double u0, double u1);

/* Function Definitions */
static double rt_powd_snf(double u0, double u1)
{
  double y;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = rtNaN;
  } else {
    double d;
    y = fabs(u0);
    d = fabs(u1);
    if (rtIsInf(u1)) {
      if (y == 1.0) {
        y = 1.0;
      } else if (y > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (d == 0.0) {
      y = 1.0;
    } else if (d == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > floor(u1))) {
      y = rtNaN;
    } else {
      y = pow(u0, u1);
    }
  }
  return y;
}

/*
 * function [coefs,maxsf,tf] = student_stop_primitive(v0,a0,sf)
 */
void student_stop_primitive(double v0, double a0, double sf, double coefs[6],
                            double *maxsf, double *tf)
{
  int i;
  /*  */
  /*           Agent Logic */
  /*          Stop Primitive */
  /*               2025 */
  /*  */
  /*  Impossible cases: negative velocity and null final position --> */
  /*  return 0 */
  /* 'student_stop_primitive:11' if (v0 <= 0) || (sf == 0) */
  if ((v0 <= 0.0) || (sf == 0.0)) {
    /* 'student_stop_primitive:12' coefs = zeros(1,6); */
    for (i = 0; i < 6; i++) {
      coefs[i] = 0.0;
    }
    /*  Returns a vector of 6 zeros for each coefficient */
    /* 'student_stop_primitive:13' tf = 0.; */
    *tf = 0.0;
    /* 'student_stop_primitive:14' maxsf = 0.; */
    *maxsf = 0.0;
    /*  Also set other returns to 0 */
  } else {
    double coefs_tmp;
    double t2;
    double t3;
    double t4;
    double t4_tmp;
    /* 'student_stop_primitive:15' else */
    /*  Can't reach a specified sf using given inputs (v0, a0) */
    /* 'student_stop_primitive:17' if 4*v0^2 + 5*a0*sf < 0 */
    t2 = 4.0 * (v0 * v0);
    if (t2 + 5.0 * a0 * sf < 0.0) {
      /* 'student_stop_primitive:18' maxsf = - (4*v0^2)/(5*a0); */
      *maxsf = -t2 / (5.0 * a0);
      /* 'student_stop_primitive:19' tf = (10*maxsf)/(2*v0); */
      *tf = 10.0 * *maxsf / (2.0 * v0);
    } else {
      /* 'student_stop_primitive:20' else */
      /*  Valid case: compute final time with defined function */
      /* 'student_stop_primitive:22' maxsf = sf; */
      *maxsf = sf;
      /* 'student_stop_primitive:23' tf = final_opt_time_stop(v0, a0, maxsf); */
      /* FINAL_OPT_TIME_STOP */
      /*     OUT1 = FINAL_OPT_TIME_STOP(V0,A0,SF) */
      /*     This function was generated by the Symbolic Math Toolbox
       * version 24.2. */
      /*     16-Oct-2025 13:13:09 */
      /* 'final_opt_time_stop:8' out1 =
       * (sf.*1.0e+1)./(v0.*2.0+sqrt(a0.*sf.*5.0+v0.^2.*4.0)); */
      *tf = sf * 10.0 / (v0 * 2.0 + sqrt(a0 * sf * 5.0 + t2));
    }
    /*  Evaluate coefficients (consider vf = af = 0) */
    /* 'student_stop_primitive:27' coefs = coef_list_fun(v0, a0, 0., 0., 0.,
     * tf); */
    /* COEF_LIST_FUN */
    /*     COEF_LIST_VAR = COEF_LIST_FUN(V0,A0,SF,VF,AF,T) */
    /*     This function was generated by the Symbolic Math Toolbox
     * version 24.2. */
    /*     16-Oct-2025 13:12:27 */
    /* 'coef_list_fun:8' t2 = T.^2; */
    t2 = *tf * *tf;
    /* 'coef_list_fun:9' t3 = af.*t2; */
    t3 = 0.0 * t2;
    /* 'coef_list_fun:10' t4 = a0.*t2.*3.0; */
    t4_tmp = a0 * t2;
    t4 = t4_tmp * 3.0;
    /* 'coef_list_fun:11' t5 = -t3; */
    /* 'coef_list_fun:12' coef_list_var =
     * [0.0,v0,a0,1.0./T.^3.*(sf.*-2.0e+1+t4+t5+T.*v0.*1.2e+1+T.*vf.*8.0).*-3.0,1.0./t2.^2.*(sf.*-3.0e+1-t3.*2.0+t4+T.*v0.*1.6e+1+T.*vf.*1.4e+1).*1.2e+1,1.0./T.^5.*(sf.*-1.2e+1+t5+T.*v0.*6.0+T.*vf.*6.0+a0.*t2).*-6.0e+1];
     */
    coefs[0] = 0.0;
    coefs[1] = v0;
    coefs[2] = a0;
    coefs_tmp = *tf * v0;
    coefs[3] = 1.0 / rt_powd_snf(*tf, 3.0) *
               (((t4 - t3) + coefs_tmp * 12.0) + *tf * 0.0 * 8.0) * -3.0;
    coefs[4] =
        1.0 / (t2 * t2) *
        ((((-0.0 - t3 * 2.0) + t4) + coefs_tmp * 16.0) + *tf * 0.0 * 14.0) *
        12.0;
    coefs[5] = 1.0 / rt_powd_snf(*tf, 5.0) *
               (((-t3 + coefs_tmp * 6.0) + *tf * 0.0 * 6.0) + t4_tmp) * -60.0;
  }
}

void student_stop_primitive_initialize(void)
{
}

void student_stop_primitive_terminate(void)
{
}

/* End of code generation (student_stop_primitive.c) */
